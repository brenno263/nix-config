# Yet Another Modular Nix Config

This configuration was made to be a single place to configure:

- multiple hosts
- multiple users
- reusable modules

# Anatomy

## `flake.nix`

This is the entrypoint of the configuration, it specifies inputs:

- nixpkgs unstable (set as default)
- nixpkgs stable
- nixos hardware tweaks
- and anything else you can dream of!
  and a single output, `nixosConfigurations`. Keyed by hostname, this holds all the system configs. Each system config should import at minimum its matching host module.

## Host Modules

In the `hosts` directory, each of these (corresponding to a nixos configuration in `flake.nix`) holds configuration for a single host.

The foundation of a host is its `configuration.nix`, this _could_ be your only file, modules are split out for, well, modularity!

Every host should also have a `hardware-configuration.nix`. Imported by the main `configuration.nix` file, this specifies some hardware specific options, like how to mount drives. This file should be autogenerated when installing Nixos to a new machine, just copy it over. You _probably_ won't _ever_ need to modify this.

Besides those two, any other config specific to a host can go in the directory! Feel free to take a peek at what already exists for some examples of what you can do.

## Modules

In the `modules` directory, there are plenty of modules holding chunks of configuration for different things. For example, `gnome.nix` turns on the GNOME desktop environment, installs a few GNOME plugins, and disables a few bits of builtin GNOME software that I don't usually want around.

These are made to be reusable! While a little opinionated, these should never include options that are intended to be specific to one host or user, like setting `hostname = "my-hostname"`. Instead if you need something like this, configure some module options so that it can be configured.

```nix
{config, lib, ...}:
{
	options.a.b.c.my-module = {
		enable = lib.mkEnableOption "my-module";

		secret = lib.mkOption {
			type = lib.types.str;
			default = null;
			description = ''
				Tell me a secret!
			'';
		};
	};

  config = lib.mkIf config.a.b.c.my-module.enable {
		environment.variables = {
			MY_SECRET = config.a.b.c.my-module.secret;
		};
  };
}
```

Often this config-referencing is streamlined with a simple let-in statement like so:

```
let
	cfg = config.a.b.c.my-module
in { environment.variables = { MY_SECRET = cfg.secret }; };
```

# User Modules

If you want the same user to have the same config across multiple hosts, use a User module! This is for configuring everything that's user-specific and host-agnostic. Much of these modules will be Home Manager config.

If you _don't_ want to use a user module, you don't have to. Just make sure that you define a user for your host in your `configuration.nix`! You don't want a system with no users.

```nix
# Define a user account. Don't forget to set a password with ‘passwd’.
users.users.johnnytest = {
	isNormalUser = true;
	description = "That boy with the flaming hair";
	extraGroups = [ "networkmanager" "wheel" ];
	# Packages specific to the user.
	packages = with pkgs; [
		neovim
	];
};
```

## Home Manager

Home Manager (HM) can be used _separately_ from NixOS, but I like to keep it in the same place as my system config. So I use the HM flake and the HM NixOS module.

```nix
# in `flake.nix`, I pass flake-inputs as a specialArg to
{ pkgs, flake-inputs, ...}
{
	imports = [
		flake-inputs.home-manager.nixosModules.default
	];

	# After importing the home-manager nixosModule, we can simply give the home-manager option an HM config.
	home-manager = {
		users.b = ./home.nix
	}
}
```
